# 모듈러 역원
정수 a와 법(모듈러) m이 주어졌을 때, 다음 식을 만족하는 x를 모듈러 m에 대한 a의 역원이라 한다.
<br>
$$ax \equiv 1 \pmod m$$
<br>
이 역원은 a와 m이 서로소(gcd(a, m)=1)일 때만 존재한다.

# 페르마의 소정리
이 방법은 모듈러 값 m이 **소수**일 때 구현이 간단하다.

#### 공식
p가 소수이고 a가 p의 배수가 아닐 때
<br>
$$a^{p-1} \equiv 1 \pmod p$$
<br>
양변을 a로 나누면
<br>
$$a^{p-2} \equiv a^{-1} \pmod p$$
<br>
즉, $a$의 역원은 $a^{p-2} \pmod p$이다.
<br>

```
def power(a, b, m):
    result = 1
    a %= m
    while b > 0:
        if b % 2 == 1:
            result = (result * a) % m
        a = (a * a) % m
        b //= 2
    return result

# 파이썬 내장함수로도 계산 가능
def modInverseFermat(a, m):
    return power(a, m-2, m)
```

<img width="1730" height="1078" alt="image" src="https://github.com/user-attachments/assets/f927b4ff-9b5f-41de-81f7-4b65bd1f2c49" />

*https://www.acmicpc.net/problem/11401*

이항 계수 공식은 $\frac{n!}{k!(n-k)!} \pmod p$ 이다. 모듈러 연산에서는 나머지 연산 중에 나눗셈을 직접 할 수 없기 때문에, 분모에 있는 $k!(n-k)!$을 **역원**으로 바꿔서 곱셈으로 만들어야 한다.

$$\text{Result} = n! \times (k!(n-k)! )^{-1} \pmod p$$ 를 구해야 한다.

페르마의 소정리에 의하면, p가 소수일 때 $a^{p-1} \equiv 1 \pmod p$ 이다. 이 식을 a로 한 번 나누면, $$a^{p-2} \equiv a^{-1} \pmod p$$ 이 되고, 식의 의미는 $a$의 역원($a^{-1}$)은 $a^{p-2}$와 같다는 뜻이 된다.

a 자리에 처리하기 곤란 했던 분모 $k!(n-k)!$을 대입해 보면
<br>

1. 분모를 $A = k!(n-k)!$이라고 둔다.
2. $A^{-1} \pmod p$를 구하고 싶다.
3. 페르마의 소정리에 의해 $A^{-1}$은 $A^{p-2} \pmod p$가 된다.

```
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
m = 1000000007

def factorial(num, mod):
    res = 1
    for i in range(2, num+1):
        res = (res * i) % mod
    return res

top = factorial(n, m)

bottom = (factorial(k, m) * factorial(n-k, m)) % m

print((top * pow(bottom, m-2, m))%m)
```


# 확장 유클리드 알고리즘
m이 소수가 아니더라도 a와 m이 소로소이기만 하면 사용할 수 있는 범용적인 방법
<br>
유클리드 호제법의 확장판으로 $ax + my = \text{gcd}(a, m)$을 만족하는 정수해 x, y를 구하는 알고리즘. 역원을 구할 때는 $\text{gcd}(a, m) = 1$이므로 식은 다음과 같다.
<br>
$$ax + my = 1$$
<br>
이 식을 모듈러 m에 대해 정리하면 $ax \equiv 1 \pmod m$이 되어, 여기서 구한 x가 곧 역원이 된다.

```
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    
    gcd, x1, y1 = extended_gcd(b%a, a)

    x = y1 - (b//a) * x1
    y = x1

    return gcd, x, y

def modInverseEEA(a, m):
    gcd, x, y = extended_gcd(a, m)
    if gcd != 1:
        return None
    else:
        return (x % m + m) % m
```
