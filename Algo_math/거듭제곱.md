## 기본 개념
수학적으로 거듭제곱은 밑(a)를 지수(n)만큼 반복해서 곱하는 연산이다.
$$a^n = a \times a \times \dots \times a \quad (n \text{ times})$$
* 시간 복잡도: $O(n)$
* 문제점: $n$이 커질수록(예: 10억 이상) 연산 속도가 급격히 느려지며, 결과값이 컴퓨터가 처리할 수 있는 정수 범위를 쉽게 초과한다.

## 분할 정복을 이용한 거듭제곱
**지수를 반으로 나누면 연산 횟수가 획기적으로 줄어드는 원리를 이용한다.**

* $n$이 짝수일 때: $a^n = a^{n/2} \times a^{n/2}$
* $n$이 홀수일 때: $a^n = a^{(n-1)/2} \times a^{(n-1)/2} \times a$
* 시간 복잡도: $O(\log n)$

```
def power(a, b, m):
    if b == 0: return 1
    tmp = power(a,b//2,m)

    if b % 2 == 0: return (tmp*tmp)%m
    else: return (tmp*tmp*a)%m
```
```
print(pow(a,b,m))
```
### 백준 1629번

<img width="1744" height="1068" alt="image" src="https://github.com/user-attachments/assets/84b3a878-1955-491b-8212-fdbd5ce55377" />

*https://www.acmicpc.net/problem/1629*

위의 알고리즘을 이용해 간단하게 풀 수 있는 기본적인 분할정복을 이용한 거듭제곱 문제이다.

## 피사노 주기
* 피보나치 수열의 각 항을 M으로 나눈 나머지는 일정한 주기를 갖게 되는데, 이를 피사노 주기라고 한다.
* 왜 필요한가?
  * 피보나치 수열의 $n$번째 항을 구해야 하는데 $n$이 10경($10^{18}$)처럼 매우 클 경우, $O(n)$이나 $O(\log n)$으로도 해결이 어려울 수 있다. 이때 주기를 이용하면 $n \pmod{\text{주기}}$번째 항을 구하는 것만으로 결과를 얻을 수 있다.
* 성질
  1. 나머지의 수열은 반드시 0, 1로 시작하는 주기를 갖는다.
  2. 나누는 수 $M = 10^k$ ($k > 2$)인 경우, 주기는 항상 $15 \times 10^{k-1}$이다.
     * $M = 10$일 때, 주기는 60
     * $M = 100$일 때, 주기는 1500
