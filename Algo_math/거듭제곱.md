## 기본 개념
수학적으로 거듭제곱은 밑(a)를 지수(n)만큼 반복해서 곱하는 연산이다.
$$a^n = a \times a \times \dots \times a \quad (n \text{ times})$$
* 시간 복잡도: $O(n)$
* 문제점: $n$이 커질수록(예: 10억 이상) 연산 속도가 급격히 느려지며, 결과값이 컴퓨터가 처리할 수 있는 정수 범위를 쉽게 초과한다.

## 분할 정복을 이용한 거듭제곱
**지수를 반으로 나누면 연산 횟수가 획기적으로 줄어드는 원리를 이용한다.**

* $n$이 짝수일 때: $a^n = a^{n/2} \times a^{n/2}$
* $n$이 홀수일 때: $a^n = a^{(n-1)/2} \times a^{(n-1)/2} \times a$
* 시간 복잡도: $O(\log n)$

```
def power(a, b, m):
    if b == 0: return 1
    tmp = power(a,b//2,m)

    if b % 2 == 0: return (tmp*tmp)%m
    else: return (tmp*tmp*a)%m
```
```
print(pow(a,b,m))
```

<br>

### 백준 1629번

<img width="1744" height="1068" alt="image" src="https://github.com/user-attachments/assets/84b3a878-1955-491b-8212-fdbd5ce55377" />

*https://www.acmicpc.net/problem/1629*

위의 알고리즘을 이용해 간단하게 풀 수 있는 기본적인 분할정복을 이용한 거듭제곱 문제이다.

<br>

## 피사노 주기
* 피보나치 수열의 각 항을 M으로 나눈 나머지는 일정한 주기를 갖게 되는데, 이를 피사노 주기라고 한다.
* 왜 필요한가?
  * 피보나치 수열의 $n$번째 항을 구해야 하는데 $n$이 10경($10^{18}$)처럼 매우 클 경우, $O(n)$이나 $O(\log n)$으로도 해결이 어려울 수 있다. 이때 주기를 이용하면 $n \pmod{\text{주기}}$번째 항을 구하는 것만으로 결과를 얻을 수 있다.
* 성질
  1. 나머지의 수열은 반드시 0, 1로 시작하는 주기를 갖는다.
  2. 나누는 수 $M = 10^k$ 인 경우, 주기는 항상 $$L = \frac{M}{10} \times 15$$이다.
     * $M = 10$일 때, 주기는 1,500,000
```
def pisano(m):
    a,b = 0,1
    for i in range(m*m):
        a,b = b,(a+b)%m
        if a==0 and b==1: return i+1

m=1000000
p = pisano(m)
n = int(input())
rn = n%p
if rn <= 1: res = rn
else:
    a,b = 0,1
    for _ in range(rn-1):
        a,b = b,(a+b)%m
    res=b
print(res)
```

주기를 찾고 그 주기를 이용해 피보나치 수열을 돌리면 되는 간단한 로직
<br>

### 백준 2749번

<img width="1736" height="1314" alt="image" src="https://github.com/user-attachments/assets/3aa3b7a9-5a3b-4421-9f17-233cf6387eaf" />

*https://www.acmicpc.net/problem/2749*

일반적인 방법으로는 풀 수 없는 피보나치 수열 문제이다.

<br>

## 행렬 거듭제곱
* 점화식을 행렬의 곱셈 형태로 변환하는 것. 피보나치 수열을 예로 들면 다음과 같다

$$\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix}$$

* 이 식을 계속 확장하면 n번째 항을 구하는 식은 다음과 같이 정리된다.

$$\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}^n \begin{pmatrix} F_1 \\ F_0 \end{pmatrix}$$

* 즉, n번째 항을 구하는 문제가 행렬을 n번 거듭제곱하는 문제로 바뀐다.

* 왜 쓰는가?
  * 앞서 정리한 분할 정복을 이용한 거듭제곱 로직을 행렬에도 그대로 적용할 수 있기 때문이다.
  * M이 피사노 주기를 쓰기 모호할 때(M이 1,000,000,007 같은 큰 수라면, 주기를 찾는 것 자체가 O(M)으로 많이 느려지게 된다.)
  * 일반 점화식: $O(n)$
  * 행렬 거듭제곱: $O(k^3 \log n)$ ($k$는 행렬의 크기)

<br>

```
def multiply(A, B, m):
    # 2x2 행렬 곱셈 예시
    C = [[0, 0], [0, 0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % m
    return C

def matrix_pow(A, n, m):
    # 단위 행렬(Identity Matrix)로 시작
    res = [[1, 0], [0, 1]]
    while n > 0:
        if n % 2 == 1:
            res = multiply(res, A, m)
        A = multiply(A, A, m)
        n //= 2
    return res
```

<br>

<img width="1732" height="1312" alt="image" src="https://github.com/user-attachments/assets/bfee546d-a940-415f-8e62-2823be09b99a" />

https://www.acmicpc.net/problem/11444
